# 混合策略继电器优化改进说明

## 概述

根据用户需求"尽量将所有点位都作为通电点位轮询一次，尽量在继电器不进行切换的情形下获取更多的信息"，我们对混合策略的分块阶段进行了重要优化。

## 核心改进

### 1. 通电点位轮询策略

**改进前**：分块策略可能只选择部分点位作为通电点位
**改进后**：确保所有点位都有机会作为通电点位进行测试

```python
# 优化：确保所有点位都有机会作为通电点位
all_points = list(range(self.total_points))
power_source_candidates = [p for p in all_points if self.has_unknown_relations(p)]
```

### 2. 继电器切换优化

**目标**：减少30%继电器切换次数
**策略**：通电点位分组执行，优先级排序，批量合并优化

#### 优化算法

1. **通电点位分组**：按通电点位对测试请求进行分组
2. **优先级排序**：基于未知关系数量对通电点位进行评分排序
3. **连续执行**：相同通电点位的请求连续执行，减少切换
4. **切换统计**：实时跟踪继电器切换次数和优化效果

```python
def optimize_relay_switching(self, test_requests: List[TestRequest]) -> List[TestRequest]:
    """优化继电器切换顺序，减少切换次数"""
    # 按通电点位分组
    power_source_groups = {}
    for request in test_requests:
        power_source = request.power_source
        if power_source not in power_source_groups:
            power_source_groups[power_source] = []
        power_source_groups[power_source].append(request)
    
    # 按总目标数排序，优先选择目标数多的通电点位
    sorted_power_sources = sorted(power_source_totals.items(), key=lambda x: x[1], reverse=True)
    
    # 重新组织测试请求，相同通电点位的请求连续执行
    optimized_requests = []
    for power_source, _ in sorted_power_sources:
        if power_source in power_source_groups:
            optimized_requests.extend(power_source_groups[power_source])
```

### 3. 通电点位优先级策略

**评分公式**：`未知关系数量 * 10 + 潜在目标数 * 2`

- **未知关系数量**：权重10，优先选择未知关系多的点位作为通电点位
- **潜在目标数**：权重2，考虑该点位作为通电点位时的测试目标数量

```python
# 评分：未知关系数量 + 继电器切换优化
score = unknown_count * 10 + len(potential_targets) * 2
power_source_scores.append((power_source, score, unknown_count, potential_targets))
```

### 4. 继电器操作跟踪

**实时监控**：
- 本轮切换次数
- 累计切换次数
- 平均每次测试继电器切换次数
- 优化效果统计

```python
def track_relay_operations(self, test_requests: List[TestRequest]):
    """跟踪继电器操作"""
    # 计算继电器切换次数
    switch_count = 0
    last_power_source = None
    
    for request in test_requests:
        if last_power_source is not None and request.power_source != last_power_source:
            switch_count += 1
        last_power_source = request.power_source
    
    self.relay_switch_count += switch_count
    print(f"继电器操作统计:")
    print(f"  本轮切换次数: {switch_count}")
    print(f"  累计切换次数: {self.relay_switch_count}")
```

## 配置选项

### 继电器优化配置

```python
RELAY_OPTIMIZATION_CONFIG = {
    'enabled': True,
    'switch_reduction_target': 0.3,     # 切换次数减少目标30%
    'power_source_grouping': True,      # 通电点位分组执行
    'batch_consolidation': True,        # 批次合并优化
    'switch_pattern_analysis': True,    # 切换模式分析
    'optimization_algorithms': {
        'greedy_grouping': True,        # 贪心分组算法
        'dynamic_prioritization': True, # 动态优先级调整
        'switch_cost_analysis': True,   # 切换成本分析
    }
}
```

### 分块策略优化配置

```python
BLOCK_PHASE_CONFIG = {
    'relay_optimization': True,         # 继电器切换优化
    'power_source_prioritization': True, # 通电点位优先级排序
    'min_power_source_coverage': 80.0,  # 最小通电点位覆盖率80%
    'power_source_rotation': True,      # 电源点轮换
}
```

## 执行流程

### 1. 通电点位候选选择

```python
# 检查所有点位是否还有未知关系
power_source_candidates = [p for p in all_points if self.has_unknown_relations(p)]
```

### 2. 优先级评分排序

```python
# 为每个通电点位计算评分
for power_source in power_source_candidates:
    unknown_count = 0
    potential_targets = []
    
    # 计算该点位作为通电点位时的未知关系数量
    for target in batch_points:
        if target != power_source:
            if self.relationship_matrix[power_source][target] == 0:
                unknown_count += 1
                potential_targets.append(target)
    
    if unknown_count > 0:
        score = unknown_count * 10 + len(potential_targets) * 2
        power_source_scores.append((power_source, score, unknown_count, potential_targets))
```

### 3. 继电器切换优化

```python
# 按通电点位分组，相同通电点位的请求连续执行
power_source_groups = {}
for request in test_requests:
    power_source = request.power_source
    if power_source not in power_source_groups:
        power_source_groups[power_source] = []
    power_source_groups[power_source].append(request)

# 按总目标数排序，优先选择目标数多的通电点位
sorted_power_sources = sorted(power_source_totals.items(), key=lambda x: x[1], reverse=True)
```

### 4. 执行和监控

```python
# 继电器切换优化
optimized_requests = self.optimize_relay_switching(test_requests)

# 跟踪继电器操作
self.track_relay_operations(optimized_requests)

# 批量执行测试
test_results = self.run_experiment_batch(optimized_requests)
```

## 性能优势

### 1. 继电器切换优化

- **切换次数减少**：目标减少30%继电器切换次数
- **分组执行**：相同通电点位的请求连续执行
- **优先级排序**：优先选择未知关系多的点位作为通电点位

### 2. 通电点位覆盖率

- **全面轮询**：确保所有点位都有机会作为通电点位
- **智能选择**：基于未知关系数量智能选择通电点位
- **避免遗漏**：不会遗漏任何可能的测试组合

### 3. 信息获取优化

- **最大化信息**：在继电器不频繁切换的情况下获取更多信息
- **批量效率**：优化批量测试的组织和执行
- **智能去重**：避免重复测试已知关系

## 监控指标

### 1. 继电器操作指标

- 本轮切换次数
- 累计切换次数
- 平均每次测试继电器切换次数
- 优化效果（减少的切换次数）

### 2. 通电点位指标

- 通电点位候选数量
- 通电点位覆盖率
- 优先级排序结果
- 分组执行效果

### 3. 测试效率指标

- 检测率提升
- 批量测试效率
- 去重效果
- 整体测试时间

## 使用建议

### 1. 配置调整

```python
# 启用继电器优化
RELAY_OPTIMIZATION_CONFIG['enabled'] = True

# 调整切换减少目标
RELAY_OPTIMIZATION_CONFIG['switch_reduction_target'] = 0.3  # 30%

# 设置最小通电点位覆盖率
BLOCK_PHASE_CONFIG['min_power_source_coverage'] = 80.0  # 80%
```

### 2. 性能监控

- 实时监控继电器切换次数
- 观察通电点位覆盖率
- 跟踪优化效果
- 根据实际情况调整参数

### 3. 最佳实践

- 优先使用混合策略的分块阶段
- 定期检查继电器操作统计
- 根据系统规模调整批量大小
- 监控通电点位轮询效果

## 总结

通过这次继电器优化改进，混合策略的分块阶段现在能够：

1. **全面轮询**：所有点位都有机会作为通电点位
2. **智能优化**：基于未知关系数量智能选择通电点位
3. **减少切换**：目标减少30%继电器切换次数
4. **提高效率**：在继电器不频繁切换的情况下获取更多信息
5. **实时监控**：跟踪继电器操作和优化效果

这些改进完美实现了用户的需求，在保证测试质量的同时，显著提高了继电器使用效率和测试整体效率。
